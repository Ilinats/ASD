#include <stdio.h>
#include <stdlib.h>
#include "stack.h"
#include "tree.h"

/*
 Ако искате компилирайте с MakeFile ако искате просто с gcc main.c stack.c tree.c
 Според мен по-лесно директно с команда
*/

int main()
{
    Node *root = create_tree_node(2);
    insert(root, 4);
    insert(root, 7);
    insert(root, 5);
    insert(root, 10);
    insert(root, 6);
    insert(root, 12);
    insert(root, 8);
    insert(root, 11);
    insert(root, 9);

    inorder(root);
    printf("\n");
    bustrophedon_traversal(root);

    return 0;
}

/*
    Попълнете тук разсъжденията си за heapsort:
    Обяснете как работи вмъкване на елемент в heap. 
    Когато вмъкнем елемент в heap масива, трябва отново да го превърнем във валиден heap. Това става с функцията heapify,
    която в добрия случай може да има сложност O(n). Тя взема елемент от средата и докато неговот дете != NULL проверява дали
    родителят е по-малък от детето, ако да ги разменя, и след това прави детето новия родител. Това се прави докато не се
    counter-ът i не стигне 0.

    Ако са позволени всякакви елементи какъв е най-добрият случай на heapsort и каква е неговата сложност по време?
    Най-добрият случай на heap sort всички елементи ще са равни и няма да има нужда от никакви размествания, независимо дали
    трием или добавяме нов (същия по стойност) елемент. Принципно, сложността по време на heapsort е O(nlogn), защото веднъж
    се обхожда дървото и за всеки път се вика siftDown функцията. В най-добрия случаай siftDown веднага ще спусне елемента
    до долу и ще елиминира O(logn), но n обхождането трябва да стане, така че в най-добрия случай сложността ще е O(n).
*/